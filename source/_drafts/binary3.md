---
title: 计算机中的二进制(3)
tags: [binary, math]
categories: 计算机原理
---

## 二进制中的符号

上面我们讨论的二进制里的小数，那么我在来看看二进制里面如何表示负数，即二进制里的符号。

我们以$byte$为例，byte占8位, 那么最大值应该是
| 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- |

换算成十进制就是255，但是为什么byte的最大值是127呢，这里就是因为我们最开始没考虑负数的情况，现在我们引入负数的二进制。

首先，我们8位二进制的范围是 **0000 0000** 到 **1111 1111**，一共可以表示$2^{8}=256$个数，如果表示无符号整数就是$[0,255]$，但是要表示有符号整数的时候就需要一个**标记位**来表示正数或者负数，在数学中，任意基数的负数都是在最前面加上“—”符号来表示， 在计算机中**原码**、**反码**、**补码**的就是为了解决计算机引入符号位的问题。

### 原码

1. 定义：最简单的机器数表示法，用最高位表示符号位，为$0$表示一个正数，为$1$表示一个负数，其他位存放该数的二进制的绝对值。

    我们来看看8位二进制的原码的表示。

    |  二进制  | 符号及值 | 无符号 |
    | :------: | :------: | :----: |
    | 00000000 |    +0    |   0    |
    | 00000001 |    1     |   1    |
    |   ...    |   ...    |  ...   |
    | 01111111 |   127    |  127   |
    | 10000000 |    −0    |  128   |
    | 10000001 |    −1    |  129   |
    |   ...    |   ...    |  ...   |
    | 11111111 |   −127   |  255   |

    可以看出这种表示方法可以表示$[-127,+127]$的数字，但是会出现两个$0000 0000(+0)$，$1000 0000(-0)$，原码表示法中，正数和负数的编码表示结果仅符号位不同，数值部分完全相同。

2. 特点：
    1. 原码的表示方法很直观，方便。
    2. 原码中0有两种不同的表示形式。
    3. 但是数字的表示是一部分，还需要考虑数字的计算，对于原码的加/减运算，需要先判定符号位，如果是不同的符号位数相加或者相同符号位相减，还需要判断两个数的数值绝对值大小，根据判断的结果决定结果符号，不利于运算。

3. 示例：
    $$
        1 + 2 = [00000001]_原 + [00000010]_原 = [00000011]_原 = 3\\
        (+0) + (-0) = [00000000]_原 + [10000000]_原 = [10000000]_原 = -0\\
        1 - 1 = 1 + (-1) = [00000001]_原 + [10000001]_原 = [10000010]_原 = -2\\
    $$
    可以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0分为+0和-0也是因它而起。

### 反码

1. 定义：正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。

    $0000 0001(1)$ 的反码为 $1111 1110(-1)$，
    反码表示的范围位$[-(2^{N-1}-1),(2^{N-1}-1)]$, 以及 $+0$, $-0$，
    八位二进制可以表示$[-127,+127]$，以及$0000 0000 (+0)$，$1111 1111 (-0)$。

    | 二进制值 | 反码表示 | 无符号数表示 |
    | -------- | -------- | ------------ |
    | 00000000 | +0       | 0            |
    | 00000001 | 1        | 1            |
    | ...      | ...      | ...          |
    | 01111101 | 125      | 125          |
    | 01111110 | 126      | 126          |
    | 01111111 | 127      | 127          |
    | 10000000 | −127     | 128          |
    |          |
    | 10000001 | −126     | 129          |
    | 10000010 | −125     | 130          |
    | ...      | ...      | ...          |
    | 11111110 | −1       | 254          |
    | 11111111 | −0       | 255          |

2. 特点：
    1. 用符号位表示数值的正负，形式与原码表示相同。
    2. 原码中0有两种不同的表示形式。
    3. 反码的表示范围与原码的表示范围相同。

3. 示例：
    $$
        1 + (-1) = [00000001]_反 + [11111110]_反 = [11111111]_反 = -0\\
        (-1) + (-3) = [11111110]_反 + [11111100]_反 = [11111010]_反 = -5\\
    $$
    互为相反数相加等于0，但是两个负数相加的出错了。

### 补码

1. 表示方式：最高位为符号位，0表示正数，1表示负数。正数的补码等于本身，负数的补码等于反码+1.

    | 二进制值 | 补码表示 | 无符号数表示 |
    | -------- | -------- | ------------ |
    | 00000000 | 0        | 0            |
    | 00000001 | 1        | 1            |
    | ...      | ...      | ...          |
    | 01111110 | 126      | 126          |
    | 01111111 | 127      | 127          |
    | 10000000 | −128     | 128          |
    | 10000001 | −127     | 129          |
    | 10000010 | −126     | 130          |
    | ...      | ...      | ...          |
    | 11111110 | −2       | 254          |
    | 11111111 | −1       | 255          |

2. 特点：
    1. 在补码表示中，用符号位表示数值的正负，形式与原码的表示相同，即0为正，1为负，但补码的符号可以看做是数值的一部分参加运算。
    2. 在补码表示中，数值0只有一种表示方法。
    3. 负数补码的表示范围比负数原码的表示范围略宽。

3. 小结：
    由于补码表示中的符号位可以与数值位一起参加运算，并且可以将减法转换为加法进行运算，简化了运算过程，因此计算机中均采用补码进行加减运算。
    使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].

4. 示例：我们来看看补码的加减
    $$
        1 + (-1) = [00000001]_补 + [11111110]_补 = ?
        (-1) + (-2) = [11111111]_补 + [11111110]_补 = ?
    $$

#### 数学的魅力

上面我们了解到了二进制的概念和不同的二进制表示方式，但是相信你跟我一样还是有许多问题：

- 补码是怎么产生的？
- 补码为什么是反码+1？
- 进制之间的转换？
- 小数的二进制如何表示？

##### 计算的加法

计算机如何把符号位参与运算，并将减法变成加法的呢？《计算机组成原理》用了个时钟的例子来说明补码：

> 将钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢？我们可以:
>
> 1. 往回拨2个小时: 6 - 2 = 4
> 2. 往前拨10个小时: (6 + 10) mod 12 = 4
> 3. 往前拨10+12=22个小时: (6+22) mod 12 =4

所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!
现在的问题就落在了如何用一个正数, 来替代一个负数。
聪明的同学已经通过上面的例子发现了端倪，我们首先来看一下同余的概率

##### 模

> 自然数的取模运算的定义是这样的（定义1）：
>
> 如果a和b是两个自然数，b非零，可以证明存在两个唯一的整数 q 和 r，满足$a = b x q + r$ 且$0 ≤ r < b$。其中，q 被称为商(quotient)，r 被称为余数(remainder)。

###### 负数取模

###### 整数除法取整

1. 向上取整
2. 向下取整
3. 向0取整

正数进行mod运算是很简单的. 但是负数呢?

>根据模的定义$a = b x q + r$，r有两个选择，一个为正，一个为负
>
>如果a、b 都是正数的话，那么一般的编程语言中，r 为正数；
>或者如果 a、b 都是负数的话，一般 r 为负数。但是如果 a、b 一正一负的话，
>不同的语言则会根据除法的不同结果而使得 r 的结果也不同，
>但是一般 r 的计算方法都会满足$r = a - (a / b) x b$

这里介绍C的处理方式

>-17 % 10 的计算结果如下：r = (-17) - (-17 / 10) x 10 = (-17) - (-1 x 10) = -7
>
>17 % -10 的计算结果如下：r = 17 - (17 / -10) x (-10) = (17) - (-1 x -10) = 7
>
>-17 % -10 的计算结果如下：r = (-17) - (-17 / -10) x (-10) = (-17) - (1 x -10) = -7

##### 同余

两个整数a，b，若它们除以整数 m 所得的余数相等，则称 a，b 对于模m同余

记作$a ≡ b (mod m)$

读作 a 与 b 关于模 m 同余。

举例说明：
> 4 mod 12 = 4
> 16 mod 12 = 4
> 28 mod 12 = 4
> -2 mod 12 = (-2) - (-2 / 12) x 12 = -2
> 10 mod 12 = 10

所以4, 16, 28关于模 12 同余.

###### 同余性质

1. 自反性：一个数永远和自己同余$a = a (mod m)$
2. 对称性：a和b同余，b和a也就同余
3. 传递性：a和b同余，b和c同余，那么a和c同余

我们回到我们的时钟问题上来

> (-2) mod 12 = 12-2=10
>
> (-4) mod 12 = 12-4 = 8
>
> (-5) mod 12 = 12-5 = 7

附录3 [^3]  列出了 4-bit 二进数所能表示的整数， 可以对照着看看区别

## 参考文章

[有符號數處理](https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86)
[二进制的原码、反码、补码](https://zhuanlan.zhihu.com/p/99082236)
[原码, 反码, 补码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)

[^2]:
|  类型   | 位数  | 默认值  |                 取值范围                  |
| :-----: | :---: | :-----: | :---------------------------------------: |
|  byte   |   8   |    0    |         $-2^{7}\thicksim2^{7}-1$          |
|  short  |  16   |    0    |        $-2^{15}\thicksim2^{15}-1$         |
|   int   |  32   |    0    |        $-2^{31}\thicksim2^{31}-1$         |
|  long   |  64   |   0L    |        $-2^{63}\thicksim2^{63}-1$         |
|  float  |  32   |  0.0f   |      $1.4E-45\thicksim3.4028235E38$       |
| double  |  64   |  0.0d   | $4.9E-324\thicksim1.7976931348623157E308$ |
|  char   |  16   | 'u0000' |      '\\u0000' $\thicksim$ '\\uffff'      |
| boolean |   8   |  false  |               true or false               |

[^3]:

- 无符号（unsigned）可表示0到15
- 原码（sign & magnitude）可表示-7到+7，包括-0
- 反码（ones' complement）可表示-7到+7，包括-0
- 补码（two's complement）可表示-8到+7，没有±0的问题

| 二进数 | 无符号 | 原码 | 反码 | 补码 |
| ------ | ------ | ---- | ---- | ---- |
| 0000   | 0      | 0    | 0    | 0    |
| 0001   | 1      | 1    | 1    | 1    |
| 0010   | 2      | 2    | 2    | 2    |
| 0011   | 3      | 3    | 3    | 3    |
| 0100   | 4      | 4    | 4    | 4    |
| 0101   | 5      | 5    | 5    | 5    |
| 0110   | 6      | 6    | 6    | 6    |
| 0111   | 7      | 7    | 7    | 7    |
| 1000   | 8      | -0   | -7   | -8   |
| 1001   | 9      | -1   | -6   | -7   |
| 1010   | 10     | -2   | -5   | -6   |
| 1011   | 11     | -3   | -4   | -5   |
| 1100   | 12     | -4   | -3   | -4   |
| 1101   | 13     | -5   | -2   | -3   |
| 1110   | 14     | -6   | -1   | -2   |
| 1111   | 15     | -7   | -0   | -1   |
