---
title: 二进制
tags: [binary, math]
categories: algorithm
---

## 什么是二进制

所谓的 二进制，就是一种仅用 $1$ 和 $0$ 的排列组合来表示具体数值的，一种记数方法。

例如 $10101000$ 就是一个二进制数，它的每位都是非$1$即$0$的，不会出现$2$或者$3$这样的其它数字。但是仅通过$1$和$0$的组合是如何表示某个具体数值的？

 | 1   | 0   | 1   | 0   | 1   | 0   | 0   | 0   |
 | --- | --- | --- | --- | --- | --- | --- | --- |

我们看上边这个例子，我们将它转换为十进制

$$
\begin{aligned}
a&=0\times2^0+0\times2^1+0\times2^2+1\times2^3+0\times2^4+1\times2^5+0\times2^6+1\times2^7 \\
 &=0+0+0+8+0+32+0+128 \\
 &=168
\end{aligned}
$$

也就是说二进制**10101000** 对应的十进制是 $168$

## 二进制 十进制及其他进制

但是还是不够清晰，跟我们小学数学的 **$0,1,2,3,4,5,6,7,8,9$** 不一样对不对，但是其实他们的记数方法是一致的，我们看下面的例子：

比如 $456$ 这个数字，我们读作 ***四百五十六***，那么 ***四百五十六*** 其实也是经过求值算出来的，具体如下：

$$
\begin{aligned}
b&=4\times10^2+5\times10^1+6\times10^0 \\
&=400+50+6 \\
&=456
\end{aligned}
$$

再回过头去看看上面二进制的求值过程，是不是很像，只是十进制的世界里是由 **$0,1,2,3,4,5,6,7,8,9$** 构成的，每位分别乘上 **$10^i$**

而在二进制世界中只有$0$,$1$，并且每位乘上的是 **$2^i$** （其中$i$是位数， 从0开始）

这个每位分别乘上的固定数值，就是所谓的 **位权（weight）**，即**每位的权重**。

一般地，$r$进制 第 $i$ 位的位权就是：**$r^i$**

## 进位

那么 **位权（weight）** 的实际意义究竟是什么呢？其实它规定了进位的规则。

比如，十进制第 $i$ 位的位权为 $r^i$ ，具体地，从第0位开始，它的每位位权分别是$1, 10, 100, 1000...$。

我们小学就学过，十进制的加法是逢十进一的，个位满十，就向十位进一。这意思可不就是，1个 十位的$1$ 代表10个 个位的$1$ 吗？

那么二进制呢？从第0位开始，二进制每位位权分别是$1, 2, 4, 8$，或者说 $2^0, 2^1,2^2,2^3...$ , 所以，二进制是**逢二进一**的。

那么一般地，$r$进制就是 逢$r$进一的。这也是为什么，它的名字叫做$r$进制。

### 进制实例

上面我们探讨了二进制的概念和记数方法，那么我们现在来看常用的数字的各进制应该是什么样的，见附录表1 [^1]

### 进制转换

各进制之间是可以相互转换的，这里先不展开讨论。

### 常见单位

上面我们讲了二进制，大家都知道计算机是以二进制存储以及发送接收数据的，二进制的一位，就叫做$1 bit$。也就是说$bit$的含义就是二进制数中的一个数位，即$0$或者$1$。**由于计算机的硬件决定，任何存储于计算机中的数据，其本质都是以二进制码存储**。

但是$bit（位）$实在太小了，还有其他常见的存储单位$Byte（字节）$、$KB（千字节）$、$MB（兆字节）$、$GB（千兆字节）$，换算如下，B是Byte的缩写:

$1B = 8bit$
$1KB = 1024B$
$1MB = 1024kB$
$1GB = 1024MB$
$1TB = 1024GB$

比如你的计算机内存是4GB，那么可以存储的位数为$4\times1024\times1024\times1024\times8$位,$1024$等于$2^{10}$, 即$32\times2^{30}$

### 计算机中为什么使用二进制

> 在计算机系统中，凡是要进行处理、存储和传输的信息，都是用二进制数进行编码的。也就是说，计算机内部采用的是二进制数表示方式。这样做的原因有以下三点：
>
> 1. 二进制数只有两种基本状态。使用有两个稳定状态的物理器件就可以表示二进制数的每一位，而制造有两个稳定状态的物理器件比要制造多个稳定状态的物理器件容易得多。例如，用高、低两个电位，或用脉冲的有、无，或用脉冲的正、负极性等，都可以很方便、很可靠的表示"0"和"1"。
> 2. 二进制的编码、计数和运算规则都简单。可以开关电路实现，简单易行。
> 3. "1"和"0"正好与逻辑命题的”真“，“假”两个值对应，为计算机中实现逻辑判断提供了便利条件。

## 二进制如何表示数据

> 数据是对事实、概念或指令的一种特殊表达形式，这种特殊表达形式可由人工或自动化装置进行处理。
> 在计算机内部，数字、文字、图形、图像、声音、视频等都不能直接由计算机进行处理和存储，它们必须采取”特殊的表达形式“才能由计算机进行通信、转换或加工处理。这种特殊的表达形式就是二进制编码形式。所以在计算机系统中的数据均是以二进制编码形式出现的。

### 二进制如何表示数值数据

#### 二进制里的小数点

#### 二进制里的符号

##### 真值

##### 原码

##### 反码

##### 补码

### 二进制如何表示非数值数据

### 有符号位的二进制

上面我们讨论的数据类型，那么我在来看看Java里的八种基础数据类型，见附录表2 [^2]。

我们以$byte$为例，byte占8位, 那么最大值应该是
| 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- |

换算成十进制就是255，但是为什么byte的最大值是127呢，这里就是因为我们最开始没考虑负数的情况，现在我们引入负数的二进制。

首先，我们8位二进制的范围是 **0000 0000** 到 **1111 1111**，一共可以表示$2^{8}=256$个数，如果表示无符号整数就是$[0,255]$，但是要表示有符号整数的时候就需要一个**标记位**来表示正数或者负数，在数学中，任意基数的负数都是在最前面加上“—”符号来表示， 在计算机中**原码**、**反码**、**补码**的就是为了解决计算机引入符号位的问题。

#### 原码

1. 定义：最简单的机器数表示法，用最高位表示符号位，为$0$表示一个正数，为$1$表示一个负数，其他位存放该数的二进制的绝对值。

    我们来看看8位二进制的原码的表示。

        |  二进制  | 符号及值 | 无符号 |
        | :------: | :------: | :----: |
        | 00000000 |    +0    |   0    |
        | 00000001 |    1     |   1    |
        |   ...    |   ...    |  ...   |
        | 01111111 |   127    |  127   |
        | 10000000 |    −0    |  128   |
        | 10000001 |    −1    |  129   |
        |   ...    |   ...    |  ...   |
        | 11111111 |   −127   |  255   |

    可以看出这种表示方法可以表示$[-127,+127]$的数字，但是会出现两个$0000 0000(+0)$，$1000 0000(-0)$，原码表示法中，正数和负数的编码表示结果仅符号位不同，数值部分完全相同。

2. 特点：
    1. 原码的表示方法很直观，方便。
    2. 原码中0有两种不同的表示形式。
    3. 但是数字的表示是一部分，还需要考虑数字的计算，对于原码的加/减运算，需要先判定符号位，如果是不同的符号位数相加或者相同符号位相减，还需要判断两个数的数值绝对值大小，根据判断的结果决定结果符号，不利于运算。

3. 示例：
    $$
        1 + 2 = [00000001]_原 + [00000010]_原 = [00000011]_原 = 3\\
        (+0) + (-0) = [00000000]_原 + [10000000]_原 = [10000000]_原 = -0\\
        1 - 1 = 1 + (-1) = [00000001]_原 + [10000001]_原 = [10000010]_原 = -2\\
    $$
    可以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0分为+0和-0也是因它而起。

#### 反码

1. 定义：正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。

    $0000 0001(1)$ 的反码为 $1111 1110(-1)$，
    反码表示的范围位$[-(2^{N-1}-1),(2^{N-1}-1)]$, 以及 $+0$, $-0$，
    八位二进制可以表示$[-127,+127]$，以及$0000 0000 (+0)$，$1111 1111 (-0)$。

        | 二进制值 | 反码表示 | 无符号数表示 |
        | -------- | -------- | ------------ |
        | 00000000 | +0       | 0            |
        | 00000001 | 1        | 1            |
        | ...      | ...      | ...          |
        | 01111101 | 125      | 125          |
        | 01111110 | 126      | 126          |
        | 01111111 | 127      | 127          |
        | 10000000 | −127     | 128          |
        |          |
        | 10000001 | −126     | 129          |
        | 10000010 | −125     | 130          |
        | ...      | ...      | ...          |
        | 11111110 | −1       | 254          |
        | 11111111 | −0       | 255          |

2. 特点：
    1. 用符号位表示数值的正负，形式与原码表示相同。
    2. 原码中0有两种不同的表示形式。
    3. 反码的表示范围与原码的表示范围相同。

3. 示例：
    $$
        1 + (-1) = [00000001]_反 + [11111110]_反 = [11111111]_反 = -0\\
        (-1) + (-3) = [11111110]_反 + [11111100]_反 = [11111010]_反 = -5\\
    $$
    互为相反数相加等于0，但是两个负数相加的出错了。

#### 补码

1. 表示方式：最高位为符号位，0表示正数，1表示负数。正数的补码等于本身，负数的补码等于反码+1.
  
        | 二进制值 | 补码表示 | 无符号数表示 |
        | -------- | -------- | ------------ |
        | 00000000 | 0        | 0            |
        | 00000001 | 1        | 1            |
        | ...      | ...      | ...          |
        | 01111110 | 126      | 126          |
        | 01111111 | 127      | 127          |
        | 10000000 | −128     | 128          |
        | 10000001 | −127     | 129          |
        | 10000010 | −126     | 130          |
        | ...      | ...      | ...          |
        | 11111110 | −2       | 254          |
        | 11111111 | −1       | 255          |

2. 特点：
    1. 在补码表示中，用符号位表示数值的正负，形式与原码的表示相同，即0为正，1为负，但补码的符号可以看做是数值的一部分参加运算。
    2. 在补码表示中，数值0只有一种表示方法。
    3. 负数补码的表示范围比负数原码的表示范围略宽。

3. 小结：
    由于补码表示中的符号位可以与数值位一起参加运算，并且可以将减法转换为加法进行运算，简化了运算过程，因此计算机中均采用补码进行加减运算。
    使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].

4. 示例：我们来看看补码的加减
    $$
        1 + (-1) = [00000001]_补 + [11111110]_补 = ?
        (-1) + (-2) = [11111111]_补 + [11111110]_补 = ?
    $$

#### 数学的魅力

上面我们了解到了二进制的概念和不同的二进制表示方式，但是相信你跟我一样还是有许多问题：

- 补码是怎么产生的？
- 补码为什么是反码+1？
- 进制之间的转换？
- 小数的二进制如何表示？

##### 计算的加法

计算机如何把符号位参与运算，并将减法变成加法的呢？《计算机组成原理》用了个时钟的例子来说明补码：

> 将钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢？我们可以:
>
> 1. 往回拨2个小时: 6 - 2 = 4
> 2. 往前拨10个小时: (6 + 10) mod 12 = 4
> 3. 往前拨10+12=22个小时: (6+22) mod 12 =4

所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!
现在的问题就落在了如何用一个正数, 来替代一个负数。
聪明的同学已经通过上面的例子发现了端倪，我们首先来看一下同余的概率

##### 模

> 自然数的取模运算的定义是这样的（定义1）：
>
> 如果a和b是两个自然数，b非零，可以证明存在两个唯一的整数 q 和 r，满足$a = b x q + r$ 且$0 ≤ r < b$。其中，q 被称为商(quotient)，r 被称为余数(remainder)。

###### 负数取模

###### 整数除法取整

1. 向上取整
2. 向下取整
3. 向0取整

正数进行mod运算是很简单的. 但是负数呢?

>根据模的定义$a = b x q + r$，r有两个选择，一个为正，一个为负
>
>如果a、b 都是正数的话，那么一般的编程语言中，r 为正数；
>或者如果 a、b 都是负数的话，一般 r 为负数。但是如果 a、b 一正一负的话，
>不同的语言则会根据除法的不同结果而使得 r 的结果也不同，
>但是一般 r 的计算方法都会满足$r = a - (a / b) x b$

这里介绍C的处理方式

>-17 % 10 的计算结果如下：r = (-17) - (-17 / 10) x 10 = (-17) - (-1 x 10) = -7
>
>17 % -10 的计算结果如下：r = 17 - (17 / -10) x (-10) = (17) - (-1 x -10) = 7
>
>-17 % -10 的计算结果如下：r = (-17) - (-17 / -10) x (-10) = (-17) - (1 x -10) = -7

##### 同余

两个整数a，b，若它们除以整数 m 所得的余数相等，则称 a，b 对于模m同余

记作$a ≡ b (mod m)$

读作 a 与 b 关于模 m 同余。

举例说明：
> 4 mod 12 = 4
> 16 mod 12 = 4
> 28 mod 12 = 4
> -2 mod 12 = (-2) - (-2 / 12) x 12 = -2
> 10 mod 12 = 10

所以4, 16, 28关于模 12 同余.

###### 同余性质

1. 自反性：一个数永远和自己同余$a = a (mod m)$
2. 对称性：a和b同余，b和a也就同余
3. 传递性：a和b同余，b和c同余，那么a和c同余

我们回到我们的时钟问题上来

> (-2) mod 12 = 12-2=10
>
> (-4) mod 12 = 12-4 = 8
>
> (-5) mod 12 = 12-5 = 7

附录4 [^4]  列出了 4-bit 二进数所能表示的整数， 可以对照着看看区别

## 参考文章

[计算机组成原理](https://book.sciencereading.cn/shop/book/Booksimple/show.do?id=B92E445A01575030BE053020B0A0AAE1D000)
[二进制是什么](https://www.zhihu.com/question/330681697/answer/1981060025)
[有符號數處理](https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86)
[二进制的原码、反码、补码](https://zhuanlan.zhihu.com/p/99082236)
[原码, 反码, 补码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)

[^1]:
| 二进制 | 十进制 | 八进制 | 十六进制 |
| :----: | :----: | :----: | :------: |
|   0    |   0    |   0    |    0     |
|   1    |   1    |   1    |    1     |
|   10   |   2    |   2    |    2     |
|   11   |   3    |   3    |    3     |
|  100   |   4    |   4    |    4     |
|  101   |   5    |   5    |    5     |
|  110   |   6    |   6    |    6     |
|  111   |   7    |   7    |    7     |
|  1000  |   8    |   10   |    8     |
|  1001  |   9    |   11   |    9     |
|  1010  |   10   |   12   |    A     |
|  1011  |   11   |   13   |    B     |
|  1100  |   12   |   14   |    C     |
|  1101  |   13   |   15   |    D     |
|  1110  |   14   |   16   |    E     |
|  1111  |   15   |   17   |    F     |
| 10000  |   16   |   20   |    10    |

[^2]:
|  类型   | 位数  | 默认值  |                 取值范围                  |
| :-----: | :---: | :-----: | :---------------------------------------: |
|  byte   |   8   |    0    |         $-2^{7}\thicksim2^{7}-1$          |
|  short  |  16   |    0    |        $-2^{15}\thicksim2^{15}-1$         |
|   int   |  32   |    0    |        $-2^{31}\thicksim2^{31}-1$         |
|  long   |  64   |   0L    |        $-2^{63}\thicksim2^{63}-1$         |
|  float  |  32   |  0.0f   |   $1.4E-45\thicksim3.4028235E38$   [^3]   |
| double  |  64   |  0.0d   | $4.9E-324\thicksim1.7976931348623157E308$ |
|  char   |  16   | 'u0000' |      '\\u0000' $\thicksim$ '\\uffff'      |
| boolean |   8   |  false  |               true or false               |

[^3]:

Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的"E+数字"表示E之前的数字要乘以10的多少次方。例如：$19971400000000=1.99714×10^13$。计算器表达10的幂是一般是用$E$或e，也就是$1.99714E13=19971400000000$。

[^4]:

- 无符号（unsigned）可表示0到15
- 原码（sign & magnitude）可表示-7到+7，包括-0
- 反码（ones' complement）可表示-7到+7，包括-0
- 补码（two's complement）可表示-8到+7，没有±0的问题

| 二进数 | 无符号 | 原码 | 反码 | 补码 |
| ------ | ------ | ---- | ---- | ---- |
| 0000   | 0      | 0    | 0    | 0    |
| 0001   | 1      | 1    | 1    | 1    |
| 0010   | 2      | 2    | 2    | 2    |
| 0011   | 3      | 3    | 3    | 3    |
| 0100   | 4      | 4    | 4    | 4    |
| 0101   | 5      | 5    | 5    | 5    |
| 0110   | 6      | 6    | 6    | 6    |
| 0111   | 7      | 7    | 7    | 7    |
| 1000   | 8      | -0   | -7   | -8   |
| 1001   | 9      | -1   | -6   | -7   |
| 1010   | 10     | -2   | -5   | -6   |
| 1011   | 11     | -3   | -4   | -5   |
| 1100   | 12     | -4   | -3   | -4   |
| 1101   | 13     | -5   | -2   | -3   |
| 1110   | 14     | -6   | -1   | -2   |
| 1111   | 15     | -7   | -0   | -1   |
