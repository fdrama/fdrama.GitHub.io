---
title: 二进制
tags: [binary, math]
categories: algorithm
---

### 常见单位

上面我们讲了二进制，大家都知道计算机是以二进制存储以及发送接收数据的，二进制的一位，就叫做$1 bit$。也就是说$bit$的含义就是二进制数中的一个数位，即$0$或者$1$。**由于计算机的硬件决定，任何存储于计算机中的数据，其本质都是以二进制码存储**。

但是$bit（位）$实在太小了，还有其他常见的存储单位$Byte（字节）$、$KB（千字节）$、$MB（兆字节）$、$GB（千兆字节）$，换算如下，B是Byte的缩写:

$1B = 8bit$
$1KB = 1024B$
$1MB = 1024kB$
$1GB = 1024MB$
$1TB = 1024GB$

比如你的计算机内存是4GB，那么可以存储的位数为$4\times1024\times1024\times1024\times8$位,$1024$等于$2^{10}$, 即$32\times2^{30}$

### 计算机中为什么使用二进制

> 在计算机系统中，凡是要进行处理、存储和传输的信息，都是用二进制数进行编码的。也就是说，计算机内部采用的是二进制数表示方式。这样做的原因有以下三点：
>
> 1. 二进制数只有两种基本状态。使用有两个稳定状态的物理器件就可以表示二进制数的每一位，而制造有两个稳定状态的物理器件比要制造多个稳定状态的物理器件容易得多。例如，用高、低两个电位，或用脉冲的有、无，或用脉冲的正、负极性等，都可以很方便、很可靠的表示"0"和"1"。
> 2. 二进制的编码、计数和运算规则都简单。可以开关电路实现，简单易行。
> 3. "1"和"0"正好与逻辑命题的”真“，“假”两个值对应，为计算机中实现逻辑判断提供了便利条件。

## 二进制如何表示数据

> 数据是对事实、概念或指令的一种特殊表达形式，这种特殊表达形式可由人工或自动化装置进行处理。
> 在计算机内部，数字、文字、图形、图像、声音、视频等都不能直接由计算机进行处理和存储，它们必须采取”特殊的表达形式“才能由计算机进行通信、转换或加工处理。这种特殊的表达形式就是二进制编码形式。所以在计算机系统中的数据均是以二进制编码形式出现的。

### 二进制如何表示数值数据

#### 二进制中的小数

前面讲过，计算机中只能识别和表示$0$和$1$，无法识别小数点，因此在计算机中处理日常中的小数数据，必须解决小数点的表示，计算机中通过
采用相应的定点与浮点表示规则来解决这个问题。

##### 定点表示

定点表示法就是约定小数点的位置，且这个位置固定不变，小数点前、后的数字，分别用二进制表示，然后组合起来就可以把这个数字在计算机中
存储起来，这种表示方式叫做「定点」表示法，用这种方法表示的数字叫做「定点数」。

1. 对于整数，其小数点总是固定在数的最右边，忽略不写。

    > $100_{D} = 01100100_{B}$

2. 对于纯小数，其小数点总是固定在数的最左边，因此可以采用一种”定点小数“来表示它。

    > $0.125_{D} = 0.00100000_{B}$

    对于纯整数和纯小数，因为小数点固定在最低位和最高位，所以它们用定点数表示时，原理是相同的，

    只需要把整数部分、小数部分，按照十进制转二进制的规则，分别转换即可。

3. 对于整数+小数形式，约定小数点位置

    假设8(bit)为例子，约定前5位表示整数部分，后3位表示小数部分
    > 1.5(D) = 00001 100(B)
    > 25.125(D) = 11001 001(B)

    用一个定点数来表示整数+小数，分为以下步骤：

    - 在有限的bit宽度下，先约定小数点的位置
    - 整数部分和小数部分，分别转换为二进制表示
    - 两部分二进制组合起来即是结果

    但是整数位的5位二进制的最大值是$11111_{B}$，十进制则是$2^4-1=31_{D}$,小数位的3位二进制，最大的是$0.111_{B}$，即十进制的$0.875_{D}$

    要表示更大范围的数，就需要扩大bit的宽度或者改变小数点的位置，小数点向后移动，整个数字范围就会扩大，但是小数部分的精度就会越来越低，没有办法表示类似 0.00001 这种高精度的值。

    在计算机内部，因为进行数据存储、运算和传输的部件的位数都是有限的，所以不管采用什么表数方法，都只能表示一定范围内的的有限个数。定点数表示小数时，表示数值范围、精度范围小，所以在计算机中，我们一般使用「浮点数」来表示小数。

##### 浮点表示

之前我们学习了定点数，其中「定点」指的是约定小数点位置固定不变。
那浮点数的「浮点」就是指，其小数点的位置是可以是漂浮不定的。

其实，浮点数是采用科学计数法的方式来表示的，例如十进制小数 8.345，用科学计数法表示，可以有多种方式：

```java
8.345 = 8.345 * 10^0
8.345 = 83.45 * 10^-1
8.345 = 834.5 * 10^-2
```

使用同样的规则，对于二进制数，我们也可以用科学计数法表示，也就是说把基数 10 换成 2 即可。
我们已经知道，浮点数是采用科学计数法来表示一个数字的，它的格式可以写成这样：

$V = (-1)^S\times M \times R^E$

其中各个变量的含义如下：

- S(Sign)：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负。
- M(Mantissa)：尾数，用小数表示，例如前面所看到的 8.345 * 10^0，8.345 就是尾数。
- R：基数，表示十进制数 R 就是 10，表示二进制数 R 就是 2。
- E(Exponent)：指数，用整数表示，例如前面看到的 10^-1，-1 即是指数，E的值确定小数的位置。

早期人们提出浮点数定义时，就是这样的情况，当时有很多计算机厂商，例如IBM、微软等，每个计算机厂商会定义自己的浮点数规则，不同厂商对同一个数表示出的浮点数是不一样的。直到1985年，IEEE 组织推出了浮点数标准，就是我们经常听到的 IEEE754 浮点数标准，这个标准统一了浮点数的表示形式，并提供了 2 种浮点格式：

|   **名称**   | **类型** | **位数** | **符号位** | **指数位** | **尾数位** |
| :----------: | :------: | :------: | :--------: | :--------: | :--------: |
| 双精度浮点数 |  float   |    32    |     1      |     8      |     23     |
| 双精度浮点数 |  double  |    64    |     1      |     11     |     52     |

为了使其表示的数字范围、精度最大化，浮点数标准还对指数和尾数进行了规定：

指数偏移值（exponent bias），是指浮点数表示法中的指数域的编码值为指数的实际值加上某个固定的值，IEEE 754标准规定该固定值为$2^{e-1}-1$ ，其中的$e$为存储指数的比特的长度。

1. 尾数 M 的第一位总是 1（因为 1 <= M < 2），因此这个 1 可以省略不写，它是个**隐藏位**，这样单精度 23 位尾数可以表示了 24 位有效数字，双精度 52 位尾数可以表示 53 位有效数字。

2. 指数 E 是个无符号整数，表示 float 时，一共占 8 bit，所以它的取值范围为 0 ~ 255。但因为指数可以是负的，所以规定在存入 E 时在它原本的值加上一个**中间数** 127，这样 E 的取值范围为 -127 ~ 128。表示 double 时，一共占 11 bit，存入 E 时加上**中间数** 1023，这样取值范围为 -1023 ~ 1024。

除了规定尾数和指数位，还做了以下规定：

|       符号位S       | 实际指数 |  指数域E  |           尾数域M            |   数值    |             含义             |
| :-----------------: | :------: | :-------: | :--------------------------: | :-------: | :--------------------------: |
|          0          |   -127   | 0000 0000 | 000 0000 0000 0000 0000 0000 |    +0     |            正数0             |
|          1          |   -127   | 0000 0000 | 000 0000 0000 0000 0000 0000 |    -0     |            负数0             |
|          0          |    0     | 0111 1111 | 000 0000 0000 0000 0000 0000 |   +1.0    |              1               |
|          1          |    0     | 0111 1111 | 000 0000 0000 0000 0000 0000 |   -1.0    |              -1              |
|          0          |   255    | 1111 1111 | 000 0000 0000 0000 0000 0000 | $+\infty$ |           正无穷大           |
|          1          |   255    | 1111 1111 | 000 0000 0000 0000 0000 0000 | $-\infty$ |           负无穷大           |
|          *          |   255    | 1111 1111 |             非0              |    NaN    | 非数字，用来表示一些特殊情况 |
| * 符号位可以为0或1. |

假设现在我们用 32 bit 表示一个浮点数，把以上变量按照一定规则，填充到这些 bit 上就可以了：

我们把 25.125 转换为标准的 float 浮点数：

1. 整数部分：$25_{D} = 11001_{B}$
2. 小数部分：$0.125_{D} = 0.001_{B}$
3. 用二进制科学计数法表示：$25.125_{D} = 11001.001_{B} = (1.1001001 \times 2^4)_{B}$

<table>
    <tr>
        <td>S</td>
        <td>E</td>
        <td>E</td>
        <td>E</td>
        <td>E</td>
        <td>E</td>
        <td>E</td>
        <td>E</td>
        <td>E</td>
        <td>E</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
        <td>M</td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>

#### 二进制中的符号

上面我们讨论的数据类型，那么我在来看看Java里的八种基础数据类型，见附录表2 [^2]。

我们以$byte$为例，byte占8位, 那么最大值应该是
| 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- |

换算成十进制就是255，但是为什么byte的最大值是127呢，这里就是因为我们最开始没考虑负数的情况，现在我们引入负数的二进制。

首先，我们8位二进制的范围是 **0000 0000** 到 **1111 1111**，一共可以表示$2^{8}=256$个数，如果表示无符号整数就是$[0,255]$，但是要表示有符号整数的时候就需要一个**标记位**来表示正数或者负数，在数学中，任意基数的负数都是在最前面加上“—”符号来表示， 在计算机中**原码**、**反码**、**补码**的就是为了解决计算机引入符号位的问题。

#### 原码

1. 定义：最简单的机器数表示法，用最高位表示符号位，为$0$表示一个正数，为$1$表示一个负数，其他位存放该数的二进制的绝对值。

    我们来看看8位二进制的原码的表示。

    |  二进制  | 符号及值 | 无符号 |
    | :------: | :------: | :----: |
    | 00000000 |    +0    |   0    |
    | 00000001 |    1     |   1    |
    |   ...    |   ...    |  ...   |
    | 01111111 |   127    |  127   |
    | 10000000 |    −0    |  128   |
    | 10000001 |    −1    |  129   |
    |   ...    |   ...    |  ...   |
    | 11111111 |   −127   |  255   |

    可以看出这种表示方法可以表示$[-127,+127]$的数字，但是会出现两个$0000 0000(+0)$，$1000 0000(-0)$，原码表示法中，正数和负数的编码表示结果仅符号位不同，数值部分完全相同。

2. 特点：
    1. 原码的表示方法很直观，方便。
    2. 原码中0有两种不同的表示形式。
    3. 但是数字的表示是一部分，还需要考虑数字的计算，对于原码的加/减运算，需要先判定符号位，如果是不同的符号位数相加或者相同符号位相减，还需要判断两个数的数值绝对值大小，根据判断的结果决定结果符号，不利于运算。

3. 示例：
    $$
        1 + 2 = [00000001]_原 + [00000010]_原 = [00000011]_原 = 3\\
        (+0) + (-0) = [00000000]_原 + [10000000]_原 = [10000000]_原 = -0\\
        1 - 1 = 1 + (-1) = [00000001]_原 + [10000001]_原 = [10000010]_原 = -2\\
    $$
    可以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0分为+0和-0也是因它而起。

#### 反码

1. 定义：正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。

    $0000 0001(1)$ 的反码为 $1111 1110(-1)$，
    反码表示的范围位$[-(2^{N-1}-1),(2^{N-1}-1)]$, 以及 $+0$, $-0$，
    八位二进制可以表示$[-127,+127]$，以及$0000 0000 (+0)$，$1111 1111 (-0)$。

    | 二进制值 | 反码表示 | 无符号数表示 |
    | -------- | -------- | ------------ |
    | 00000000 | +0       | 0            |
    | 00000001 | 1        | 1            |
    | ...      | ...      | ...          |
    | 01111101 | 125      | 125          |
    | 01111110 | 126      | 126          |
    | 01111111 | 127      | 127          |
    | 10000000 | −127     | 128          |
    |          |
    | 10000001 | −126     | 129          |
    | 10000010 | −125     | 130          |
    | ...      | ...      | ...          |
    | 11111110 | −1       | 254          |
    | 11111111 | −0       | 255          |

2. 特点：
    1. 用符号位表示数值的正负，形式与原码表示相同。
    2. 原码中0有两种不同的表示形式。
    3. 反码的表示范围与原码的表示范围相同。

3. 示例：
    $$
        1 + (-1) = [00000001]_反 + [11111110]_反 = [11111111]_反 = -0\\
        (-1) + (-3) = [11111110]_反 + [11111100]_反 = [11111010]_反 = -5\\
    $$
    互为相反数相加等于0，但是两个负数相加的出错了。

#### 补码

1. 表示方式：最高位为符号位，0表示正数，1表示负数。正数的补码等于本身，负数的补码等于反码+1.

    | 二进制值 | 补码表示 | 无符号数表示 |
    | -------- | -------- | ------------ |
    | 00000000 | 0        | 0            |
    | 00000001 | 1        | 1            |
    | ...      | ...      | ...          |
    | 01111110 | 126      | 126          |
    | 01111111 | 127      | 127          |
    | 10000000 | −128     | 128          |
    | 10000001 | −127     | 129          |
    | 10000010 | −126     | 130          |
    | ...      | ...      | ...          |
    | 11111110 | −2       | 254          |
    | 11111111 | −1       | 255          |

2. 特点：
    1. 在补码表示中，用符号位表示数值的正负，形式与原码的表示相同，即0为正，1为负，但补码的符号可以看做是数值的一部分参加运算。
    2. 在补码表示中，数值0只有一种表示方法。
    3. 负数补码的表示范围比负数原码的表示范围略宽。

3. 小结：
    由于补码表示中的符号位可以与数值位一起参加运算，并且可以将减法转换为加法进行运算，简化了运算过程，因此计算机中均采用补码进行加减运算。
    使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].

4. 示例：我们来看看补码的加减
    $$
        1 + (-1) = [00000001]_补 + [11111110]_补 = ?
        (-1) + (-2) = [11111111]_补 + [11111110]_补 = ?
    $$

#### 数学的魅力

上面我们了解到了二进制的概念和不同的二进制表示方式，但是相信你跟我一样还是有许多问题：

- 补码是怎么产生的？
- 补码为什么是反码+1？
- 进制之间的转换？
- 小数的二进制如何表示？

##### 计算的加法

计算机如何把符号位参与运算，并将减法变成加法的呢？《计算机组成原理》用了个时钟的例子来说明补码：

> 将钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢？我们可以:
>
> 1. 往回拨2个小时: 6 - 2 = 4
> 2. 往前拨10个小时: (6 + 10) mod 12 = 4
> 3. 往前拨10+12=22个小时: (6+22) mod 12 =4

所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!
现在的问题就落在了如何用一个正数, 来替代一个负数。
聪明的同学已经通过上面的例子发现了端倪，我们首先来看一下同余的概率

##### 模

> 自然数的取模运算的定义是这样的（定义1）：
>
> 如果a和b是两个自然数，b非零，可以证明存在两个唯一的整数 q 和 r，满足$a = b x q + r$ 且$0 ≤ r < b$。其中，q 被称为商(quotient)，r 被称为余数(remainder)。

###### 负数取模

###### 整数除法取整

1. 向上取整
2. 向下取整
3. 向0取整

正数进行mod运算是很简单的. 但是负数呢?

>根据模的定义$a = b x q + r$，r有两个选择，一个为正，一个为负
>
>如果a、b 都是正数的话，那么一般的编程语言中，r 为正数；
>或者如果 a、b 都是负数的话，一般 r 为负数。但是如果 a、b 一正一负的话，
>不同的语言则会根据除法的不同结果而使得 r 的结果也不同，
>但是一般 r 的计算方法都会满足$r = a - (a / b) x b$

这里介绍C的处理方式

>-17 % 10 的计算结果如下：r = (-17) - (-17 / 10) x 10 = (-17) - (-1 x 10) = -7
>
>17 % -10 的计算结果如下：r = 17 - (17 / -10) x (-10) = (17) - (-1 x -10) = 7
>
>-17 % -10 的计算结果如下：r = (-17) - (-17 / -10) x (-10) = (-17) - (1 x -10) = -7

##### 同余

两个整数a，b，若它们除以整数 m 所得的余数相等，则称 a，b 对于模m同余

记作$a ≡ b (mod m)$

读作 a 与 b 关于模 m 同余。

举例说明：
> 4 mod 12 = 4
> 16 mod 12 = 4
> 28 mod 12 = 4
> -2 mod 12 = (-2) - (-2 / 12) x 12 = -2
> 10 mod 12 = 10

所以4, 16, 28关于模 12 同余.

###### 同余性质

1. 自反性：一个数永远和自己同余$a = a (mod m)$
2. 对称性：a和b同余，b和a也就同余
3. 传递性：a和b同余，b和c同余，那么a和c同余

我们回到我们的时钟问题上来

> (-2) mod 12 = 12-2=10
>
> (-4) mod 12 = 12-4 = 8
>
> (-5) mod 12 = 12-5 = 7

附录4 [^4]  列出了 4-bit 二进数所能表示的整数， 可以对照着看看区别

## 参考文章

[计算机组成原理](https://book.sciencereading.cn/shop/book/Booksimple/show.do?id=B92E445A01575030BE053020B0A0AAE1D000)
[二进制是什么](https://www.zhihu.com/question/330681697/answer/1981060025)
[有符號數處理](https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86)
[二进制的原码、反码、补码](https://zhuanlan.zhihu.com/p/99082236)
[原码, 反码, 补码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)
[什么是浮点数](https://zhuanlan.zhihu.com/p/339949186)
[什么是定点数](https://zhuanlan.zhihu.com/p/338588296)
[一文读懂浮点数](https://zhuanlan.zhihu.com/p/349572768)
[^1]:
| 二进制 | 十进制 | 八进制 | 十六进制 |
| :----: | :----: | :----: | :------: |
|   0    |   0    |   0    |    0     |
|   1    |   1    |   1    |    1     |
|   10   |   2    |   2    |    2     |
|   11   |   3    |   3    |    3     |
|  100   |   4    |   4    |    4     |
|  101   |   5    |   5    |    5     |
|  110   |   6    |   6    |    6     |
|  111   |   7    |   7    |    7     |
|  1000  |   8    |   10   |    8     |
|  1001  |   9    |   11   |    9     |
|  1010  |   10   |   12   |    A     |
|  1011  |   11   |   13   |    B     |
|  1100  |   12   |   14   |    C     |
|  1101  |   13   |   15   |    D     |
|  1110  |   14   |   16   |    E     |
|  1111  |   15   |   17   |    F     |
| 10000  |   16   |   20   |    10    |

[^2]:
|  类型   | 位数  | 默认值  |                 取值范围                  |
| :-----: | :---: | :-----: | :---------------------------------------: |
|  byte   |   8   |    0    |         $-2^{7}\thicksim2^{7}-1$          |
|  short  |  16   |    0    |        $-2^{15}\thicksim2^{15}-1$         |
|   int   |  32   |    0    |        $-2^{31}\thicksim2^{31}-1$         |
|  long   |  64   |   0L    |        $-2^{63}\thicksim2^{63}-1$         |
|  float  |  32   |  0.0f   |   $1.4E-45\thicksim3.4028235E38$   [^3]   |
| double  |  64   |  0.0d   | $4.9E-324\thicksim1.7976931348623157E308$ |
|  char   |  16   | 'u0000' |      '\\u0000' $\thicksim$ '\\uffff'      |
| boolean |   8   |  false  |               true or false               |

[^3]:

Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的"E+数字"表示E之前的数字要乘以10的多少次方。例如：$19971400000000=1.99714×10^13$。计算器表达10的幂是一般是用$E$或e，也就是$1.99714E13=19971400000000$。

[^4]:

- 无符号（unsigned）可表示0到15
- 原码（sign & magnitude）可表示-7到+7，包括-0
- 反码（ones' complement）可表示-7到+7，包括-0
- 补码（two's complement）可表示-8到+7，没有±0的问题

| 二进数 | 无符号 | 原码 | 反码 | 补码 |
| ------ | ------ | ---- | ---- | ---- |
| 0000   | 0      | 0    | 0    | 0    |
| 0001   | 1      | 1    | 1    | 1    |
| 0010   | 2      | 2    | 2    | 2    |
| 0011   | 3      | 3    | 3    | 3    |
| 0100   | 4      | 4    | 4    | 4    |
| 0101   | 5      | 5    | 5    | 5    |
| 0110   | 6      | 6    | 6    | 6    |
| 0111   | 7      | 7    | 7    | 7    |
| 1000   | 8      | -0   | -7   | -8   |
| 1001   | 9      | -1   | -6   | -7   |
| 1010   | 10     | -2   | -5   | -6   |
| 1011   | 11     | -3   | -4   | -5   |
| 1100   | 12     | -4   | -3   | -4   |
| 1101   | 13     | -5   | -2   | -3   |
| 1110   | 14     | -6   | -1   | -2   |
| 1111   | 15     | -7   | -0   | -1   |
