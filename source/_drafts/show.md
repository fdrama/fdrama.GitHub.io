# show

1. 高性能QPS系统设计

- 服务器硬件基础，CPU、内存、磁盘、网络

CPU（中央处理器）：

作用：CPU是服务器的大脑，负责处理所有的计算和指令执行。
影响：CPU的性能直接影响服务器处理请求的速度和并发处理能力。高频率和多核心的CPU可以更快地处理复杂的计算任务和同时处理更多的请求。
内存（RAM）：

作用：内存是服务器的短期存储区域，用于临时存储正在运行的程序和数据。
影响：内存的大小和速度决定了服务器能够同时运行的程序数量和处理大型数据集的能力。内存不足可能导致服务器性能下降，甚至出现应用程序崩溃。
磁盘（存储设备）：

作用：磁盘用于长期存储数据，包括操作系统、应用程序和用户数据。
影响：磁盘的容量、读写速度和可靠性对服务器的数据存储和检索效率至关重要。高速SSD磁盘可以大幅提升数据读写速度，从而提高服务器的整体性能。
网络（网络接口）：

作用：网络接口连接服务器与外部世界，负责数据的传输和接收。
影响：网络带宽和延迟直接影响服务器与客户端之间的通信速度和稳定性。高带宽和低延迟的网络可以支持更多的并发连接和更快的数据传输，提高用户体验。

- 负载均衡

硬件负载均衡：
软件负载均衡： Nginx, HAProxy 根据预设的规则和算法来分发请求。 轮询、随机、最少连接、IP哈希、URL哈希等。
云负载均衡：AWS ELB, Azure Load Balancer, 云服务商提供的负载均衡服务。

作用：负载均衡器用于将请求分发到多台服务器上，以实现请求的均衡分配和高可用性，避免单一资源过载。

- 数据库设计

1. 高性能数据库 Mysql
2. 合理的表结构和索引
3. 数据库读写分离，主从同步

- 缓存设计

1. 缓存技术：Redis、Memcached
2. 缓存策略：LRU、LFU、FIFO
3. 缓存更新策略：Cache-Aside、Write-Through、Write-Behind
4. 缓存一致性问题
5. 缓存穿透、缓存雪崩、缓存击穿

- 程序设计

1. 高性能编程语言：Golang、C/C++、Java
2. 多线程、协程、异步编程
3. 高性能框架：Netty、Vert.x、Spring Boot
4. 数据结构和算法优化
5. 代码优化和调优
6. 高性能IO模型：Reactor、Proactor、多路复用
7. 高性能序列化：Protobuf、Thrift、Avro
8. 高性能RPC框架：gRPC、Dubbo、Thrift
9. 高性能缓存框架：Ehcache、Guava Cache、Caffeine
10. 高性能数据库连接池：HikariCP、Druid
11. 高性能消息队列：Kafka、RabbitMQ、RocketMQ
12. 高性能搜索引擎：Elasticsearch、Solr
13. 高性能Web服务器：Nginx、Apache、Tomcat
14. 高性能分布式存储：HDFS、Ceph、GlusterFS
15. 高性能分布式计算：Hadoop、Spark、Flink
16. 高性能分布式缓存：Redis Cluster、Memcached Cluster

2. 操作系统部分

- 死锁的四个必要条件

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
5. 避免死锁的方法：破坏死锁的四个必要条件之一。

- 线程共享变量的方法

1. Volatile 关键字

当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。

而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。

3. JVM

- JVM 内存结构
- JVM 类加载机制
- JVM 垃圾回收算法
- JVM 性能调优

4. 数据库

- 数据库事务的四大特性

1. 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。
2. 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。
3. 隔离性（Isolation）：多个事务并发执行时，事务之间是相互隔离的，一个事务的执行不应影响其他事务。
4. 持久性（Durability）：事务一旦提交，对数据库的修改是永久性的，即使数据库发生故障也能恢复。

- 数据库隔离级别

|隔离级别 | 脏读 | 不可重复读 | 幻读 |
|-- | -- | -- | -- |
|-- 读未提交（Read Uncommitted） | 是 | 是 | 是 |
|-- 读已提交（Read Committed） | 否 | 是 | 是 |
|-- 可重复读（Repeatable Read） | 否 | 否 | 是 |
|-- 串行化（Serializable） | 否 | 否 | 否 |

- 锁的类型

按照锁的粒度，可以分为表锁和行锁。

1. 共享锁（Shared Lock）：允许多个事务同时读取同一资源，但只允许一个事务写入资源。亦称读锁。
2. 排他锁（Exclusive Lock）：只允许一个事务读取或写入资源，其他事务不能同时读取或写入。亦称写锁。

按照锁的范围，可以分为表锁和行锁。

1. 表锁（Table Lock）：锁定整个表，适用于大批量操作数据的场景。
2. 行锁（Row Lock）：锁定表中的某一行数据，适用于频繁更新单行数据的场景。

按照锁的实现方式，可以分为乐观锁和悲观锁。

1. 乐观锁（Optimistic Lock）：先读取数据，然后在更新数据时检查数据是否被其他事务修改过，如果没有则更新成功，否则回滚。
2. 悲观锁（Pessimistic Lock）：先锁定数据，然后再进行读取和更新操作，其他事务必须等待锁释放。

- 数据库并发控制

MVCC（Multi-Version Concurrency Control）多版本并发控制是一种数据库事务并发控制的方法，主要用于解决读-写冲突和写-写冲突。

InnoDB 存储引擎通过 MVCC 实现了事务的隔离级别，保证了事务的一致性和并发性。依赖于两个隐藏的列来实现 MVCC，分别记录了行数据的创建版本号和删除版本号。

SELECT
    a. INNODB 只查找版本早于当前事务版本的数据行（行的版本号<=事务的版本号），这样可以确保事务读取的行是事务开始时的行快照，从而实现了读已提交（Read Committed）的隔离级别。
    b. 行的删除版本要么未定义，要么大于当前事务版本号，这样可以确保事务读取的行在事务开始时是存在的。
INSERT
    a. 为新插入的每一行保存当前系统版本号作为行版本号。
UPDATE
    a. 不更新原来的行，而是将原来的行标记为删除，然后插入一条新的行，保存当前系统版本号作为行版本号。
DELETE
    a. 为删除的每一行保存当前系统版本号作为行版本号。

只在READ COMMITTED和REPEATABLE READ隔离级别下使用MVCC，因为这两个隔离级别下，InnoDB可以使用MVCC来提高并发性能。

预写式日志（Write-Ahead Logging，WAL）是一种数据库事务日志的写入策略，主要用于保证事务的持久性和一致性。

两阶段锁定协议（Two-Phase Locking Protocol）是一种数据库事务并发控制的方法，主要用于解决读-写冲突和写-写冲突。

- 隐式锁定（Implicit Locking）：在事务执行过程中，数据库自动为事务加锁，直到事务结束时才释放锁。
- 显式锁定（Explicit Locking）：在事务执行过程中，需要手动为数据加锁和释放锁。

SELECT ... FOR UPDATE：获取排他锁，其他事务不能读取和写入该行数据。
SELECT ... LOCK IN SHARE MODE：获取共享锁，其他事务可以读取但不能写入该行数据。

间隙锁

间隙锁（Gap Lock）是一种数据库事务并发控制的方法，主要用于解决幻读问题。

间隙锁是一种特殊的行锁，用于锁定一个范围而不是单个行。当事务对一个范围的数据进行读取时，数据库会为该范围的数据加上间隙锁，防止其他事务在该范围内插入新的数据。

间隙锁的作用是防止幻读，即事务在读取数据时，其他事务不能在该范围内插入新的数据，保证了事务读取的数据是一致的。

## Schema类型

- 更小的类型通常更好，因为它们占用更少的磁盘、内存和CPU缓存。
- 简单就好
- 尽量避免NULL

整数类型

UNSIGNED属性 无符号属性，表示该列不存储负数，可以存储更大的正数。

|类型 | 存储大小 | 范围 |
|-- | -- | -- |
|-- TINYINT | 8位 | -2^7 ~ 2^7-1 ,unsigned:0 ~ 2^8-1 |
|-- SMALLINT | 16位 | -2^15 ~ 2^15-1 ,unsigned:0 ~ 2^16-1 |
|-- MEDIUMINT | 24位 | -2^23 ~ 2^23-1 ,unsigned:0 ~ 2^24-1 |
|-- INT | 32位 | -2^31 ~ 2^31-1 ,unsigned:0 ~ 2^32-1 |
|-- BIGINT | 64位 | -2^63 ~ 2^63-1 ,unsigned:0 ~ 2^64-1 |

实数类型

FLOAT和DOUBLE类型用于存储浮点数，DECIMAL类型用于存储精确的小数。

但是存储数据的精度和范围是有限的，因此在设计数据库时，需要根据实际需求选择合适的类型。

在需要高精度的场景下，可以使用DECIMAL类型，它可以存储精确的小数，但是会占用更多的存储空间。

也可以将数字乘以一个固定的倍数，转换为整数存储（BIGINT），然后在应用程序中进行转换。

字符串类型

CHAR和VARCHAR类型用于存储字符串，CHAR类型用于存储固定长度的字符串，VARCHAR类型用于存储可变长度的字符串。

VARCHAR需要使用1或2个字节来存储字符串的长度， 255个字符以下使用1个字节，否则使用2个字节。

CHAR类型适用于存储固定长度的字符串，例如MD5、UUID等固定长度的字符串。

BLOB和TEXT类型用于存储二进制数据和文本数据，BLOB类型用于存储二进制数据，TEXT类型用于存储文本数据。

BLOB和TEXT类型有4种大小：TINY、MEDIUM、LONG、BIG，分别对应不同的存储大小。尽量避免使用BLOB和TEXT类型，因为它们会占用更多的存储空间。

日期和时间类型

DATE、TIME、DATETIME和TIMESTAMP类型用于存储日期和时间数据，DATE类型用于存储日期，TIME类型用于存储时间，DATETIME类型用于存储日期和时间，TIMESTAMP类型用于存储时间戳。

## 索引

- 索引是一种数据结构，用于加快数据库的查询速度。

最左前缀原则：索引的最左前缀可以有效利用索引，例如索引(a,b,c)可以用于查询条件a、a和b、a和b和c。

索引类型

- B-Tree索引：适用于等值查询和范围查询，例如=、>、<、IN、BETWEEN等。
- Hash索引：适用于等值查询
 a. 哈希索引只包含哈希值和行指针，不包含实际的数据。
 b. 哈希索引数据不是按照索引顺序存储的，因此无法支持范围查询和排序。
 c. 哈希索引不支持最左前缀原则，只能使用索引的全部列进行查询。
 d. 哈希索引适用于等值查询，例如=、IN等。不支持范围查询，例如>、<、BETWEEN等。
 e. 哈希索引应避免哈希冲突，否则会导致性能下降。遍历链表中的所有行指针，直到找到匹配的行。

> 可以冗余一个列存储哈希值，用于快速定位行指针。查询时先计算哈希值，然后使用哈希索引查找行指针。 

```sql
SELECT * FROM table WHERE hash_column = hash_value and column = value;
```

- 全文索引：适用于文本数据的全文搜索，例如MATCH AGAINST。用的比较少。

三星索引：

索引将相关的记录放在一起则为一星
索引的数据顺序和查找中的排列顺序一致则获得二星
索引的列包含查询需要的全部列则获得三星

独立索引
前缀索引
多列索引

索引优缺点

- 优点

a. 大大减少服务器需要扫描的数据量。
b. 帮助服务器避免排序和临时表。
c. 将随机I/O变为顺序I/O。

## 查询优化

1. 查询不需要的列 - 只返回需要的列
2. 多表关联时返回全部的列 - 只返回需要的列
3. 总是取出全部的列 SELECT * FROM table
4. 重复查询相同的数据  - 缓存

三个指标

1. 查询响应时间
2. 扫描的行数
3. 返回的行数

EXPLAIN

- id：查询的序列号，表示查询的顺序，id相同的查询是同一层次的查询。
- select_type：查询的类型，包括SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT等。
- table：查询的表名，表示查询的是哪个表。
- partitions：查询的分区，表示查询的是哪个分区。
- type：查询的类型，包括ALL、index、range、ref、eq_ref、const、system、null等。
- possible_keys：查询的可能使用的索引。
- key：查询的实际使用的索引。
- key_len：查询的索引长度。
- ref：查询的比较列。
- rows：查询的扫描行数，表示查询需要扫描的行数。
- filtered：查询的过滤行数，表示查询的过滤条件。
- extra：查询的额外信息，包括Using where、Using index、Using temporary、Using filesort等。

type 说明

- ALL：全表扫描，表示需要扫描整个表。
- index：全索引扫描，表示需要扫描整个索引。
- range：范围扫描，表示需要扫描索引的一部分。
- ref：索引查找，表示使用非唯一索引进行查找。
- eq_ref：唯一索引查找，表示使用唯一索引进行查找。
- const：表示通过一次索引查找就可以找到记录。常出现于primary key或者unique key的查询。
- system：system是const类型的特例，当查询的表只有一行记录时使用system。
- null：无效索引查找，表示没有使用索引进行查找。

```sql

|id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |
|-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
|-- 1 | SIMPLE | user | NULL | ALL | NULL | NULL | NULL | NULL | 1000 | 10.00 | Using where |
