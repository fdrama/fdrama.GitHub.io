---
title: 计算机中的二进制（二）
tags:
  - binary
  - math
categories: 计算机原理
mathjax: true
date: 2022-08-11 17:52:20
---


数据是对事实、概念或指令的一种特殊表达形式，这种特殊表达形式可由人工或自动化装置进行处理。在计算机内部，数字、文字、图形、图像、声音、视频等都不能直接由计算机进行处理和存储，它们必须采取”特殊的表达形式“才能由计算机进行通信、转换或加工处理。这种特殊的表达形式就是二进制编码形式，**在计算机系统中的数据均是以二进制编码形式出现的**。

## 二进制中的小数

前面讲过，计算机中只能识别和表示$0$和$1$，无法识别小数点，因此在计算机中处理日常中的小数数据，必须解决小数点的表示，计算机中通过采用相应的定点与浮点表示规则来解决这个问题。

### 定点表示

定点表示法就是约定小数点的位置，且这个位置固定不变，小数点前、后的数字，分别用二进制表示，然后组合起来就可以把这个数字在计算机中存储起来，这种表示方式叫做「定点」表示法，用这种方法表示的数字叫做「定点数」。

1. 对于整数，其小数点总是固定在数的最右边，忽略不写。

    $100_{D} = 01100100_{B}$

2. 对于纯小数，其小数点总是固定在数的最左边，因此可以采用一种”定点小数“来表示它。

    $0.125_{D} = 0.00100000_{B}$

3. 对于整数+小数形式，约定小数点位置

    假设8(bit)为例子，约定前5位表示整数部分，后3位表示小数部分
    $1.5(D) = 00001 \ 100(B)$
    $25.125(D) = 1100 \ 1001(B)$

    用一个定点数来表示整数+小数，分为以下步骤：

    - 在有限的bit宽度下，先约定小数点的位置
    - 整数部分和小数部分，分别转换为二进制表示
    - 两部分二进制组合起来即是结果

    但是整数位的5位二进制的最大值是$11111_{B}$，十进制则是$2^4-1=31_{D}$,小数位的3位二进制，最大的是$0.111_{B}$，即十进制的$0.875_{D}$

    要表示更大范围的数，就需要扩大bit的宽度或者改变小数点的位置，小数点向后移动，整个数字范围就会扩大，
    但是小数部分的精度就会越来越低，没有办法表示类似 0.00001 这种高精度的值。

    在计算机内部，因为进行数据存储、运算和传输的部件的位数都是有限的，所以不管采用什么表数方法，都只能表示一定范围内的的有限个数。
    定点数表示小数时，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大的数或者特别小的数。
    因此，最终绝大多数现代的计算机系统都采纳了所谓的浮点数表达法。所以在计算机中，我们一般使用**浮点数**来表示小数。

### 浮点表示

之前我们学习了定点数，其中「定点」指的是约定小数点位置固定不变。那浮点数的「浮点」就是指，其小数点的位置是可以是漂浮不定的。

浮点数是采用**科学计数法**的方式来表示的，我们先以十进制小数举例，例如8.345，用科学计数法表示，可以有多种方式：

$
\begin{aligned}
8.345&=8.345\times10^0\\\\
&=83.45\times10^-1\\\\
&=834.5\times10^-2
\end{aligned}
$

因为这种表达的多样性，因此有必要对其加以规范化以达到统一表达的目标。规范的浮点数表达方式具有如下形式：

$$
\pm d.dd...d \times \beta^{e} (0 \leq d_{i} < \beta)
$$

其中，d.dd…d 为有效数字，β 为基数，e 为指数。
有效数字中数字的个数称为精度，我们可以用 p 来表示，即可称为 p 位有效数字精度。每个数字 d 介于 0 和基数 β 之间，包括 0。可以写成以下形式：
$$
\pm (d_0 + d_{1}\beta^{-1}+...+d_{p-1}\beta^{-(p-1)}) \times \beta^{e} (0 \leq d_{i} < \beta)
$$

其中，对十进制的浮点数，即基数 β 等于 10 的浮点数而言，上面的表达式非常容易理解。
如 12.34，我们可以根据上面的表达式表达为：$1×10^1+2×10^0+3×10^{-1}+4×10^{-2}$，其规范浮点数表达为$1.234×10^1$。

使用同样的规则，对于二进制数，我们也可以用科学计数法表示，也就是说把基数 10 换成 2 即可。而每个数字 d 只能在 0 和 1 之间取值。如二进制数 1001.101，我们可以根据上面的表达式表达为：$1×2^3+0×2^2+0×2^1+1×2^0+1×2^{-1}+0×2^{-2}+1×2^{-3}$，其规范浮点数表达为 $1.001101×2^3$。

### IEEE 浮点数标准

直到 20 世纪 80 年代（即在没有制定 IEEE 754 标准之前），业界还没有一个统一的浮点数标准。相反，很多计算机制造商根据自己的需要来设计自己的浮点数表示规则，以及浮点数的执行运算细节。另外，他们常常并不太关注运算的精确性，而把实现的速度和简易性看得比数字的精确性更重要，而这就给代码的可移植性造成了重大的障碍。
一个统一的标准应用而生：IEEE 于 1985 年制订了二进制浮点运算标准 IEEE 754，该标准限定指数的底为 2，并于同年被美国引用为 ANSI 标准。
目前，几乎所有的计算机都支持 IEEE 754 标准，它大大地改善了科学应用程序的可移植性。

IEEE 浮点数标准是从逻辑上用三元组{S，E，M}来表示一个数 V 的。

$
V = (-1)^S\times M \times 2^E  (1 \leq M < 2)
$

其中各个变量的含义如下：

- S(Sign)：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负；
- M(Mantissa)：尾数位，也称为有效数字位，是二进制小数；
- E(Exponent)：指数，用整数表示，是 2 的幂（可能是负数），它的作用是对浮点数加权，E的值确定小数的位置；

在计算机中，把浮点数的位表示划分为3段：

- 一个单独的符号位 s；
- k 位的阶码字段 $exp=e_{k−1}...e_1e_0$ 编码阶码 $E$；
- n 位小数字段 $frac=f_{n−1}...f_1f_0$ 编码尾数$M$，编码出来的值依赖于阶码字段的值是否等于0；

举例来说：

10进制中的$9.0$在二进制中写成$1001.0$，也就是 $1.001×2^3$，按照上面的格式，可以算出 $S=0, M=1.001, E=3$。

<table width="%50">
    <tr>
        <td width="10%">S（符号位）</td>
        <td width="15%">E（指数位）</td>
        <td width="25%">M（尾数位）</td>
    </tr>
</table>

IEEE 754规定，对于32位的浮点数，最高的1位是符号位$S$，接着的8位是指数$E$，剩下的23位为有效数字$M$。

![bin-32](binary2/bin-32.png)

对于64位的浮点数，最高的1位是符号位$S$，接着的11位是指数$E$，剩下的52位为有效数字$M$。

![bin-64](binary2/bin-64.png)

|   **名称**   | **类型** | **位数** | **符号位** | **指数位** | **尾数位** |
| :----------: | :------: | :------: | :--------: | :--------: | :--------: |
| 双精度浮点数 |  float   |    32    |     1      |     8      |     23     |
| 双精度浮点数 |  double  |    64    |     1      |     11     |     52     |

#### 指数偏移值（exponent bias）

指数E的指数位为8，那么表示的范围是$[0, 2^8-1]$，即$[0, 255]$，指数可以为正数，也可以为负数，因此范围就是$[-127,127]$，但是二进制是无符号的，为了解决负数表示的问题，由不引入其他概念，就引入了偏移量（移码、偏置码）的概念。

***指数偏移量*** 指浮点数表示法中的指数域的编码值为指数的实际值加上某个固定的值，IEEE 754标准规定该固定值为$2^{e-1}-1$ ，其中的$e$为存储指数的比特的长度。

根据定义，指数位为8位的偏移量就是$2^{7}-1 = 127$，当实际指数是-127 时，指数域的值其实是0，也就是$0000 0000$。

因为偏移量的存在由此产生指数的取值范围是：单精度为 $-126 \leq E \leq +127$，双精度为 $-1022 \leq E \leq +1023$ 。

#### 隐藏位

尾数 M 的第一位总是 1（因为 1 <= M < 2），因此这个 1 可以省略不写，它是个**隐藏位**，这样单精度 23 位尾数可以表示了 24 位有效数字，双精度 52 位尾数可以表示 53 位有效数字。

我们来举例说明一下，8.25 用 float 表示的二进制应该是什么样子的：

1. 先看整数位 $8_{D} = 1000_{2}$
2. 再看小数位 $0.25_{D} = 0.1_{2}$
3. 组合起来 $8.25_{D} = 1000.01_{2}$
4. 写成科学计数法 $1000.01 = 1.00001 \times 2^3$
5. 结合浮浮点数标准公式，可知 $S = 0, E = 3, M = 1.00001$
6. 符号为正，那么第一位填0，指数是3，加上偏移量127等于130，二进制表示为10000010，剩下的尾数1.00001 去除隐藏位剩下 00001 填到尾数位上即可。把以上变量填充到这些 bit 上就可以了：

##### 特殊数值

| 符号位S | 实际指数 |  指数域E  |           尾数域M            |   数值    |             含义             |
| :-----: | :------: | :-------: | :--------------------------: | :-------: | :--------------------------: |
|    0    |   -127   | 0000 0000 | 000 0000 0000 0000 0000 0000 |    +0     |            正数0             |
|    1    |   -127   | 0000 0000 | 000 0000 0000 0000 0000 0000 |    -0     |            负数0             |
|    0    |   255    | 1111 1111 | 000 0000 0000 0000 0000 0000 | $+\infty$ |           正无穷大           |
|    1    |   255    | 1111 1111 | 000 0000 0000 0000 0000 0000 | $-\infty$ |           负无穷大           |
|    *    |   255    | 1111 1111 |             非0              |    NaN    | 非数字，用来表示一些特殊情况 |

##### 浮点数的范围

##### 浮点数的计算

###### 浮点数舍入方式

|  **名称**  |                          **描述**                          |
| :--------: | :--------------------------------------------------------: |
| 向偶数舍入 | 也称为向最接近的值舍入，会将结果舍入为最接近且可以表示的值 |
|  向0舍入   |                    会将结果朝0方向舍入                     |
|  向上舍入  |     向$+\infty$方向舍入，会将结果朝正无穷大的方向舍入      |
|  向下舍入  |     向$-\infty$方向舍入，会将结果朝负无穷大的方向舍入      |

### 小结

## 参考文章

[什么是浮点数](https://zhuanlan.zhihu.com/p/339949186)
[什么是定点数](https://zhuanlan.zhihu.com/p/338588296)
[一文读懂浮点数](https://zhuanlan.zhihu.com/p/349572768)
[计算机中浮点数的二进制表示](http://www.ideabuffer.cn/2017/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/)
[IEEE 754浮点数标准详解](http://c.biancheng.net/view/314.html)

[^1]:

Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的"E+数字"表示E之前的数字要乘以10的多少次方。例如：$19971400000000=1.99714×10^{13}$。计算器表达10的幂是一般是用$E$或e，也就是$1.99714E13=19971400000000$。
