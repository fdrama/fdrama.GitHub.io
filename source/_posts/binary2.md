---
title: 计算机中的二进制（二）
tags:
  - binary
  - math
categories: 计算机原理
mathjax: true
date: 2022-08-11 17:52:20
---


数据是对事实、概念或指令的一种特殊表达形式，这种特殊表达形式可由人工或自动化装置进行处理。在计算机内部，数字、文字、图形、图像、声音、视频等都不能直接由计算机进行处理和存储，它们必须采取”特殊的表达形式“才能由计算机进行通信、转换或加工处理。这种特殊的表达形式就是二进制编码形式，**在计算机系统中的数据均是以二进制编码形式出现的**。

## 二进制中的小数

前面讲过，计算机中只能识别和表示$0$和$1$，无法识别小数点，因此在计算机中处理日常中的小数数据，必须解决小数点的表示，计算机中通过采用相应的定点与浮点表示规则来解决这个问题。

### 定点表示

定点表示法就是约定小数点的位置，且这个位置固定不变，小数点前、后的数字，分别用二进制表示，然后组合起来就可以把这个数字在计算机中存储起来，这种表示方式叫做「定点」表示法，用这种方法表示的数字叫做「定点数」。

1. 对于整数，其小数点总是固定在数的最右边，忽略不写。

    $100_{D} = 01100100_{B}$

2. 对于纯小数，其小数点总是固定在数的最左边，因此可以采用一种”定点小数“来表示它。

    $0.125_{D} = 0.00100000_{B}$

3. 对于整数+小数形式，约定小数点位置

    假设8(bit)为例子，约定前5位表示整数部分，后3位表示小数部分
    $1.5(D) = 00001 \ 100(B)$
    $25.125(D) = 1100 \ 1001(B)$

    用一个定点数来表示整数+小数，分为以下步骤：

    - 在有限的bit宽度下，先约定小数点的位置
    - 整数部分和小数部分，分别转换为二进制表示
    - 两部分二进制组合起来即是结果

    但是整数位的5位二进制的最大值是$11111_{B}$，十进制则是$2^4-1=31_{D}$,小数位的3位二进制，最大的是$0.111_{B}$，即十进制的$0.875_{D}$。

    要表示更大范围的数，就需要扩大bit的宽度或者改变小数点的位置，小数点向后移动，整个数字范围就会扩大，但是小数部分的精度就会越来越低，没有办法表示类似$0.00001$这种高精度的值。

### 浮点表示

在计算机内部，因为进行数据存储、运算和传输的部件的位数都是有限的，所以不管采用什么表数方法，都只能表示一定范围内的的有限个数。
定点数表示小数时，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大的数或者特别小的数。
因此，最终绝大多数现代的计算机系统都采纳了所谓的浮点数表达法。所以在计算机中，我们一般使用**浮点数**来表示小数。

之前我们学习了定点数，其中「定点」指的是约定小数点位置固定不变。那浮点数的「浮点」就是指，其小数点的位置是可以是漂浮不定的。

浮点数是采用**科学计数法**的方式来表示的，我们先以十进制小数举例，例如8.345，用科学计数法表示，可以有多种方式：

$
\begin{aligned}
8.345&=8.345\times10^0\\\\
&=83.45\times10^-1\\\\
&=834.5\times10^-2
\end{aligned}
$

因为这种表达的多样性，因此有必要对其加以规范化以达到统一表达的目标。规范的浮点数表达方式具有如下形式：

$$
\pm d.dd...d \times \beta^{e} (0 \leq d_{i} < \beta)
$$

其中，d.dd…d 为有效数字，$β$为基数，$e$为指数。
有效数字中数字的个数称为精度，我们可以用$p$来表示，即可称为$p$位有效数字精度。每个数字$d$介于$0$和基数$β$之间，可以写成以下形式：
$$
\pm (d_0 + d_{1}\beta^{-1}+...+d_{p-1}\beta^{-(p-1)}) \times \beta^{e} (0 \leq d_{i} < \beta)
$$

其中，对十进制的浮点数，即基数$β$等于$10$的浮点数而言，上面的表达式非常容易理解。
如 12.34，我们可以根据上面的表达式表达为：$1×10^1+2×10^0+3×10^{-1}+4×10^{-2}$，其规范浮点数表达为$1.234×10^1$。

使用同样的规则，对于二进制数，我们也可以用科学计数法表示，也就是说把基数$10$换成$2$即可。而每个数字$d$只能在$0$和$1$之间取值。如二进制数$1001.101$，我们可以根据上面的表达式表达为：$1×2^3+0×2^2+0×2^1+1×2^0+1×2^{-1}+0×2^{-2}+1×2^{-3}$，其规范浮点数表达为 $1.001101×2^3$。

### IEEE 浮点数标准

直到 20 世纪 80 年代（即在没有制定 IEEE 754 标准之前），业界还没有一个统一的浮点数标准。相反，很多计算机制造商根据自己的需要来设计自己的浮点数表示规则，以及浮点数的执行运算细节。另外，他们常常并不太关注运算的精确性，而把实现的速度和简易性看得比数字的精确性更重要，而这就给代码的可移植性造成了重大的障碍。

一个统一的标准应用而生：IEEE 于 1985 年制订了二进制浮点运算标准 IEEE 754，该标准限定指数的底为 2，并于同年被美国引用为 ANSI 标准。目前，几乎所有的计算机都支持 IEEE 754 标准，它大大地改善了科学应用程序的可移植性。

IEEE 浮点数标准是从逻辑上用三元组{S，E，M}来表示一个数 V 的。

$
V = (-1)^S\times M \times 2^E  (1 \leq M < 2)
$

其中各个变量的含义如下：

- S(Sign)：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负；
- M(Mantissa)：尾数位，也称为有效数字位，是二进制小数；
- E(Exponent)：指数，用整数表示，是 2 的幂（可能是负数），它的作用是对浮点数加权，E的值确定小数的位置；

在计算机中，把浮点数的位表示划分为3段：

- 一个单独的符号位 s；
- k 位的阶码字段 $exp=e_{k−1}...e_1e_0$ 编码阶码 $E$；
- n 位小数字段 $frac=f_{n−1}...f_1f_0$ 编码尾数$M$，编码出来的值依赖于阶码字段的值是否等于0；

<table width="%50">
    <tr>
        <td width="10%">S（符号位）</td>
        <td width="15%">E（指数位）</td>
        <td width="25%">M（尾数位）</td>
    </tr>
</table>

举例来说：

10进制中的$9.0$在二进制中写成$1001.0$，也就是 $1.001×2^3$，按照上面的格式，可以算出 $S=0, M=1.001, E=3$。

IEEE 754规定，对于32位的浮点数，最高的1位是符号位$S$，接着的8位是指数$E$，剩下的23位为有效数字$M$。

![bin-32](binary2/bin-32.png)

对于64位的浮点数，最高的1位是符号位$S$，接着的11位是指数$E$，剩下的52位为有效数字$M$。

![bin-64](binary2/bin-64.png)

|   **名称**   | **类型** | **位数** | **符号位** | **指数位** | **尾数位** |
| :----------: | :------: | :------: | :--------: | :--------: | :--------: |
| 双精度浮点数 |  float   |    32    |     1      |     8      |     23     |
| 双精度浮点数 |  double  |    64    |     1      |     11     |     52     |

对于上述位的表示，根据阶段$exp$的表示，可以分为三种情况：

#### 规格化的值

这是一般的情况，当$exp$的二进制表示中**既不全为0，也不全为1**（单精度格式8位，数值为255；双精度格式11位，数值为2047）时，都是规格化数组。
这种情况下，阶码字段被解释为以偏置（biased）形式表示的有符号整数。

##### 指数偏移量（exponent bias）

*指数偏移量* 指浮点数表示法中的指数域的编码值为指数的实际值加上某个固定的值，IEEE标准规定该固定值为$2^{k-1}-1$ ，其中的$k$为存储指数的比特的长度。

那么偏移量解决的时什么问题呢，以float为例，指数E的指数位为8位bit，那么表示的范围是$[0, 2^8-1]$，即$[0, 255]$，指数可以为正数，也可以为负数，因此范围就是$[-127,127]$，但是二进制是无符号的，为了解决负数表示的问题，由不引入其他概念，就引入了偏移量（移码、偏置码）的概念，用无符号数来表示有符号数；

也就是说，阶码的值是$E=e-Bias$，其中$e$是无符号数。

例如指数$E=-126$ , 那么在指数域的表示就应该是$-126+127=1_{D}={00000001}_2$；同样，指数$E=127$，那么指数域的表示就应该是$127+127=254_{D}=11111110_{2}$

因为偏移量的存在由此产生指数的取值范围是：单精度为 $-126 \leq E \leq +127$，双精度为 $-1022 \leq E \leq +1023$。

##### 隐藏位

小数字段$frac$被解释为描述小数值$f$， 其中$0 \leq f <1$，其二进制表示为$0.f_{n−1}⋯f_{1}f_{0}$，也就是二进制小数点在最高有效位的左边。
尾数定义为$M=1+f$。我们可以把$M$看成是一个$1.f_{n−1}f_{n−2}...f_{0}$的数字。尾数$M$的第一位总是$1$（$1 \leq M <2$），因此这个$1$可以省略不写，它是个*隐藏位*，这样单精度23位尾数可以表示了24位有效数字，双精度52位尾数可以表示53位有效数字。

我们来举例说明一下，$8.25$用 float 表示的二进制应该是什么样子的：

$
\begin{aligned}
8_{D} = 1000_{2}  \quad &先转换整数位 \\\\
0.25_{D} = 0.1_{2} \quad &再转换小数位 \\\\
8.25_{D} = 1000.01_{2}  \quad &组合起来 \\\\
1000.01 = 1.00001 \times 2^3 &书写成科学计数法方式 \\\\
\end{aligned}
$

因为8.25是正数，所以$S=0$，指数$E=3$，所以指数段为$3+127=130_{D}=10000010_{B}$，有效数字省略掉小数点左侧的$1$之后为00001，然后在右侧用零补齐。因此所得的最终结果为：

| 1 | 10000010 | 00001000000000000000000 |
|:---:|:--------:|:-----------------------:|

#### 非规格化的值

当阶码位全为0时，表示的数就是非规格化的形式。这种情况下，阶码的值是$E=1−Bias$，而有效数字的值是$M=f$，也就是小数字段的值不包括隐含的1。

![unnormal](binary2/2-1PZ511393c48.jpg)

<table>
    <tr>
        <td rowspan="2">描述</td>
        <td rowspan="2">指数</td>
        <td rowspan="2">小数</td>
        <td colspan="2">单精度</td>
        <td colspan="2">双精度</td>
    </tr>
    <tr>
        <td>值</td>
        <td>十进制</td>
        <td>值</td>
        <td>十进制</td>
    </tr>
     <tr>
        <td>最小非格式化数</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>

非规格化数有两个用途。

1. 它们提供了一种表示数值0的方法，因为使用规格化数时，必须总是使$M \geq 1$，这样就不能表示0。实际上，+0.0的浮点表示的位模式为全0：符号位是0，阶码字段全为0（表示是一个非规格化的值），而小数域也全为0，这就得到$M=f=0$。但当符号位为1，其他域全为0时，会得到−0.0。根据IEEE的浮点格式，值 +0.0 和 −0.0在某些方面被认为是不同的，而在其他方面是相同的。
2. 另外一个功能是表示哪些非常接近于$0.0$的数。它们提供了一种属性，称为逐渐溢出（gradual underflow），其中，可能的数值分布均匀地接近于 0.0。

#### 特殊数值

当阶码全为1时出现的。当小数域全为0时，得到的值表示无穷。当把两个非常大的数相乘，或者除以0时，无穷可以表示溢出的结果。当小数域为非零时，结果值被称为”NAN“。

| 符号位S | 实际指数 |  指数域E  |           尾数域M            |   数值    |             含义             |
| :-----: | :------: | :-------: | :--------------------------: | :-------: | :--------------------------: |
|    0    |   -127   | 0000 0000 | 000 0000 0000 0000 0000 0000 |    +0     |            正数0             |
|    1    |   -127   | 0000 0000 | 000 0000 0000 0000 0000 0000 |    -0     |            负数0             |
|    0    |   255    | 1111 1111 | 000 0000 0000 0000 0000 0000 | $+\infty$ |           正无穷大           |
|    1    |   255    | 1111 1111 | 000 0000 0000 0000 0000 0000 | $-\infty$ |           负无穷大           |
|    *    |   255    | 1111 1111 |             非0              |    NaN    | 非数字，用来表示一些特殊情况 |

### 浮点数的范围

我们再来看一下，用浮点数表示一个数字，其范围和精度能有多大？

以float为例，它能表示的最大数肯定是指数域$E=127$，尾数域$M=1.111...1（小数点后23个1）$

### 精度问题

### 浮点数的计算

#### 浮点数舍入方式

|  **名称**  |                          **描述**                          |
| :--------: | :--------------------------------------------------------: |
| 向偶数舍入 | 也称为向最接近的值舍入，会将结果舍入为最接近且可以表示的值 |
|  向0舍入   |                    会将结果朝0方向舍入                     |
|  向上舍入  |     向$+\infty$方向舍入，会将结果朝正无穷大的方向舍入      |
|  向下舍入  |     向$-\infty$方向舍入，会将结果朝负无穷大的方向舍入      |

### 小结

## 参考文章

[什么是浮点数](https://zhuanlan.zhihu.com/p/339949186)
[什么是定点数](https://zhuanlan.zhihu.com/p/338588296)
[一文读懂浮点数](https://zhuanlan.zhihu.com/p/349572768)
[计算机中浮点数的二进制表示](http://www.ideabuffer.cn/2017/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/)
[IEEE 754浮点数标准详解](http://c.biancheng.net/view/314.html)

[^1]:

Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的"E+数字"表示E之前的数字要乘以10的多少次方。例如：$19971400000000=1.99714×10^{13}$。计算器表达10的幂是一般是用$E$或e，也就是$1.99714E13=19971400000000$。
